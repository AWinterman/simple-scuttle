<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Scuttlebutt Gossip Protocols">
  <title>Scuttlebutt</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="style.css">
  <script type="text/javascript" src="./bundle.js" async></script>
</head>
<body>
<header>
<h1 class="title">scuttlebutt</h1>
<h2 class="author"><strong><a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">Scuttlebutt Gossip Protocols</a></strong></h2>
<h3 class="date">with <a href="https://github.com/mbostock/d3/wiki/Force-Layout">d3 force directed layouts</a> and node.js</h3>
</header>
<article>
<p>For best viewing, use chrome, opera or safari.</p>
<section id="a-basic-example" class="level2">
<h2>A Basic Example</h2>
<p>Clicking on a star causes it to change its own state– the length of each point of the star represents how many times it has been clicked. Each star propagates its state across the network via a <a href="https://github.com/awinterman/simple-scuttle">JavaScript implementation</a> of the <a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">scuttlebutt gossip protocol</a>.</p>
<p>Every 30 milliseconds, a randomly chosen node gossips with the nodes connected to it by an edge. All edges are bidirectional.</p>
</section>
<section id="the-protocol" class="level2">
<h2>The Protocol</h2>
<p>In <em>Efﬁcient Reconciliation and Flow Control for Anti-Entropy Protocols</em>, van Rennesse et al. model state as a key value store. So each node maintains a hash from keys to values and version numbers. Whenever they apply a new update, locally they give it a larger version number than any seen before.</p>
<p>Each node also maintains a history of the updates it has seen, both locally and from other nodes. When one node gossips with another, they first exchange a digest– this is a list of tuples of every peer they’ve seen an update from, and the version number for that update. Upon receiving the digest each node selects from it’s history updates from the specified peers newer than the version number in the digest. It orders these updates with lowest version number first, and then sends them off until it has used up it’s allotted bandwidth. It then waits until another session of gossip to write any additional information.</p>
<p>Scuttlebutt is cpu and network efficient, and <strong>eventually</strong> consistent.</p>
</section>
<section id="history-and-compaction" class="level2">
<h2>History and Compaction <a href="#history-and-compaction">§</a></h2>
<p>In <a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">the paper</a>, where nodes need not abide by practical limitations such as browser performance, the authors assume that each node can hold on to a complete history of all the updates that have ever been applied to it. Updates are simply snapshots of a piece of the state, so it should be safe to throw out old updates once the node receives a new one for the same part of state. <a href="https://github.com/awinterman/simple-scuttle">Simple-scuttle</a> allows the user to bound the number of updates to hold on to. Once the bound is reached, each time a new update is written to the history, an old one is thrown out.</p>
<p>There is a hook whereby the client can implement her own compaction of history. The scuttlebutt instance has a <code>.history</code> attribute which emits <code>update</code> events whenever a new update is applied, and <code>compaction</code> events whenever writing the new update will cause it to throw out an old one.</p>
</section>
<section id="versioning" class="level2">
<h2>Versioning <a href="#conflicts">§</a></h2>
<p>How do peers decided when to apply updates? How do they know an update occuring elsewhere happened before their own update? Scuttlebutt applies a partial ordering on updates by means of a <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">a vector clock</a>, described in full in <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">Lamport 1978</a>. It works, more or less as follows:</p>
<p>Suppose peers <code>A</code>, <code>B</code> must exhange updates. They will each maintain a vector of logical times for each peer. Logical time refers to the number of events the peer has seen. This vector is called the <code>clock</code>, and is updated according to the following two rules (IR1 and IR2 from <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">the paper</a>):</p>
<ol type="1">
<li>Each peer must update it’s own entry in the list between any two updates</li>
<li>If A sends an update to B, it must also send along the logical time, <code>t</code>, at which the update occured. Upon receive the update, B updates A’s entry in its own clock to <code>t</code>, and then ensures its own entry in its clock is greater than <code>t</code>.</li>
</ol>
<p>In the beginning, they each maintain a vector clock that looks like this:</p>
<pre><code>A : [0, 0] 
B : [0, 0]</code></pre>
<p>Now A receives a local update, so it updates its own entry in its clock.</p>
<pre><code>A : [1, 0] 
B : [0, 0]</code></pre>
<p>When A gossips with B, it sends an update along with the version number at which the update occured, in this case <code>1</code>. B applies the update since it has a version number since <code>1</code> is higher than the most recent time it has seen. It also increments its own version number to be one higher than A’s. Note that no event is marked with time 2.</p>
<pre><code>A : [1, 0] 
B : [1, 2] </code></pre>
<p>Now B encounters a local update, so it increments it’s own clock.</p>
<pre><code>A: [1, 0] 
B: [1, 3]</code></pre>
<p>And sends the new update to A:</p>
<pre><code>A: [4, 3]
B: [1, 3]</code></pre>
</section>
<section id="conflict" class="level2">
<h2>Conflict</h2>
<p>What happens if B encounters another local update?</p>
<pre><code>A: [4, 3] 
B: [1, 4]</code></pre>
<p>When B sends it’s update to A, A will merrily apply the update rules, arriving at:</p>
<pre><code>A: [5, 4]
B: [1, 4]</code></pre>
<p>But A is still left to resolve which of <code>[4, 3]</code> and <code>[1, 4]</code> came first. It turns out it cannot do so without appeal to external heauristics or physical time, a difficult task across a distributed network.</p>
<p>Lamport recommends reading <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=1091674&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1091674"><em>Dissemination of System Time</em> by Ellingson et al.</a>, but the paper remains behind a tall paywall<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup>, so I haven’t been able to read it.</p>
<p>During my research (furious googling for the most part), heuristics proved the more common approach. Some are maddeningly arbitrary. For example, <a href="https://wiki.apache.org/cassandra/FAQ#clocktie">Cassandra</a>, which uses scuttlebutt to propagate updates across its network, orders updates by their value. It gives primacy to <code>DELETE</code> operations, which is to say if <code>A</code> sent <code>DELETE key</code> to <code>B</code>, then no matter what the value of concurrent (as far as the vector clock is concerned) updates, <code>key</code> is deleted from the <code>B</code>’s store. If non-delete updates occur simultaneously, Cassandra saves the update which <strong>is lexically larger</strong>!</p>
<p>In the <a href="https://github.com/dominictarr/scuttlebutt/blob/master/model.js">scuttlebutt/model</a> of <a href="http://npmjs.org/scuttlebutt">npm.im/scuttlebutt</a>, <a href="https://github.com/dominictarr">@dominictarr</a> <a href="https://github.com/dominictarr/scuttlebutt/blob/master/util.js#L29-L36">lexically compares</a> node names to resolve conflicts between nodes, essentially attributing credibility based on alphabetically sorting node names.</p>
<p>Like the <a href="http://npmjs.org/scuttlebutt">npm.im/scuttlebutt</a> base class, <a href="https://github.com/awinterman/simple-scuttle">simple-scuttle</a> leaves the definition of the resolution function to the user, via a parameter to the constructor function called <a href="https://github.com/AWinterman/simple-scuttle#constructor"><code>should_apply</code></a>. Conceivably, you could implement your own clock synchronization algorithm, and plug in its results here.</p>
</section>
<section id="relation-to-npm.imscuttlebutt-and-van-renesse-et-al.scuttlebutt" class="level2">
<h2>Relation to <a href="http://npmjs.org/scuttlebutt">npm.im/scuttlebutt</a> and <em><a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">van Renesse et al.</a></em> <a href="#relation-to-npm.imscuttlebutt-and-van-renesse-et-al.scuttlebutt">§</a></h2>
<p>My implementation, and consequently this module, was inspired by <a href="http://npmjs.org/scuttlebutt">Dominic Tarr’s scuttlebut module</a>, which, though totally awesome, I found the source hard to parse, which was problematic for me since it was designed to be subclassed. I also found it difficult to draw parallels between <a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">the paper</a> and this implementation. So I wrote my own.</p>
<p>These two implementations should cover roughly the same ground, presenting two different APIs and implementations of the same concept.</p>
<p>My goal in writing it was to gain a deeper understanding of the gossip protocol, as it pertains to concepts such as node.js’s buffering streams. As such this module bears some fidelity to the paper– I intended to replicate terminology from the paper faithfully, subject of course to the restrictions imposed by the format and language (javascript rather than maths), although once I had internalized the concepts this ceased to be a conscious effort.</p>
</section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>If anyone has contact information for the author, or is able to grant legitimate free access to the paper, please <a href="https://twitter.com/andywinterman">contact me</a><a href="#fnref1">↩</a></p></li>
</ol>
</section>
</article>
</body>
</html>
