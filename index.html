<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="A Scuttlebutt Demo">
  <title>Scuttlebutt</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="style.css">
  <script type="text/javascript" src="./bundle.js" async></script>
</head>
<body>
<header>
<h1 class="title">scuttlebutt</h1>
<h2 class="author"><strong><a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">A Scuttlebutt Demo</a></strong></h2>
<h3 class="date">with <a href="https://github.com/mbostock/d3/wiki/Force-Layout">d3 force directed layouts</a> and node.js</h3>
</header>
<nav id="TOC">
<ul>
<li><a href="#what-is-it">What is it?</a></li>
<li><a href="#the-protocol">The Protocol</a></li>
<li><a href="#the-vector-clock">The Vector Clock</a></li>
<li><a href="#conflict">Conflict</a></li>
<li><a href="#relation-to-npm.imscuttlebuttand-van-renesse-et-al.">Relation to npm.im/scuttlebuttand <em>van Renesse et al.</em></a></li>
</ul>
</nav>
<article>
<aside class="admonition">
For best viewing, use chrome, opera or safari.
</aside>

<section class=container>
<section class=example><svg></svg></section>
<section id="what-is-it" class="level2">
<h2><a href="#what-is-it">What is it?</a></h2>
<p>This is a demo of <em>Simple-Scuttle</em>, a <a href="https://github.com/awinterman/simple-scuttle">Javascript implementation</a> of the Scuttlebutt gossip protocol as it is described in <a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">van Renesse et al.</a>. <em>Simple-Scuttle</em> builds on the <a href="http://nodejs.org/">node.js</a> core library, leveraging node streams<sup><a href="#fn1" class="footnoteRef" id="fnref1">1</a></sup> to manage data over time, meaning it plays well with other elements of node core, like <code>http</code> or <code>tcp</code>.</p>
<p><a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">Scuttlebutt</a> is a protocol for flow control and efficient reconciliation– meaning it propagates information across a network, and does it well. In general, the network could be any distributed system– computers distributed in space, processes in a single machine, or as is the case here, svg polygons (<img src="./assets/ten.svg" alt="inline-ten" />) in the DOM.</p>
<p>Polygons, <img src="./assets/pair.svg" alt="pair" />, <img src="./assets/ten.svg" alt="ten" />, or <img src="./assets/twenty.svg" alt="twenty" /> represent nodes in the network. In the toy examples here, each node is responsible for a single value - the number of times it has been clicked - and each node reports that value to the nodes with which it shares an edge.</p>
<p><strong>Click on a node to update its state!</strong></p>
<p>The state at each node is represented by the polygon’s shape- there is one point per node in the network, so <img src="./assets/pair.svg" alt="pair" /> describes the initial the state of a network with two nodes in it, and <img src="./assets/ten.svg" alt="ten" /> a network with ten. When the user clicks on a node, its corresponding point distends,</p>
<aside class=inline>
so after a few clicks, <img src="./assets/pair.svg" alt="full" /> might turn into <img src="./assets/distended-pair.svg" alt="full" />.
</aside>

</section></section>
<section class=container>
<section class=example><svg></svg></section>
<section id="the-protocol" class="level2">
<h2><a href="#the-protocol">The Protocol</a></h2>
<p><em>I recommend reading the <a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">paper</a> for the full story, including a discussion of Scuttlebutt’s performance characteristics.</em></p>
<p>There are essentially three data structures to Scuttlebutt– some sort of store for the state, a <a href="http://npm.im/vector-clock-class">vector clock</a>, which helps determine what updates to ask for, and a structure for replaying, compacting, and holding on to <a href="https://github.com/AWinterman/simple-scuttle/blob/master/lib/history.js">history</a>. Additionally, there is an etiquette for how gossip should happen.</p>
<p>The vector clock allows sensible application of version numbers to all updates, and ensures that updates received by a node can be at least partially ordered by a <code>precedes</code> relation, which allows quick exchange about the most recent information a given node has seen.</p>
<p>The history data structure keeps track of new updates as they come in, and can replay all updates from a given node in chronological order upon request.</p>
<p>Gossip between two peers begins by exchanging vector clocks– each peer sends the other a list of highest version number they’ve seen from each other node in the network (including themselves).</p>
<p>For example, suppose <img src="./assets/pair.svg" alt="pair" /> sends its vector clock to <img src="./assets/red-pair.svg" alt="red-pair" />. In that list there’s the two-ple (<img src="./assets/red-pair.svg" alt="red-pair" />, 10), so <img src="./assets/red-pair.svg" alt="red-pair" /> responds with all the updates it has heard about from itself (e.g. local updates) with version numbers greater than 10, ordering them in chronological order. <img src="./assets/red-pair.svg" alt="red-pair" /> sends them one at a time until it has sent them all, or exceeded the its bandwidth. The next time <img src="./assets/red-pair.svg" alt="red-pair" /> and <img src="./assets/pair.svg" alt="pair" /> gossip, they will again exchange vector clocks, which will ensure that they neither repeate themselves nor leave anything out. This extends directly to a more complicated network, since gossip is always pairwise.</p>
<p>Scuttlebutt is cpu and network efficient, and <strong>eventually</strong> consistent.</p>
</section></section>
<section class=container>
<section class=example><svg></svg></section>
<section id="the-vector-clock" class="level2">
<h2><a href="#the-vector-clock">The Vector Clock</a></h2>
<p>How do we assign version numbers to updates occuring across a distributed network? How does one node tell an update coming from a peer occured before a local update?</p>
<p>Scuttlebutt <a href="partial-ordering">partially orders</a> updates by means of a <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">a vector clock</a>, described in full in <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">Lamport 1978</a>. It works, more or less as follows:</p>
<p>Suppose nodes <code>A</code>, <code>B</code> must exhange updates. Each node maintains a vector, called the <code>clock</code> of logical times<sup><a href="#fn2" class="footnoteRef" id="fnref2">2</a></sup> for each node in the network. The <code>clock</code> is updated according to the following two rules (IR1 and IR2 from <a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf">the paper</a>):</p>
<ol type="1">
<li>Each peer must update it’s own entry in the vector between any two updates</li>
<li>If A sends an update to B, it must also send along the logical time, <code>t</code>, at which the update occured. Upon receive the update, B updates A’s entry in its own clock to <code>t</code>, and then ensures its own entry in its clock is greater than <code>t</code>.</li>
</ol>
<p>In the beginning, they each maintain a vector clock that looks like this:</p>
<pre><code>A : [0, 0] 
B : [0, 0]</code></pre>
<p>Now A receives a local update, so it updates its own entry in its clock.</p>
<pre><code>A : [1, 0] 
B : [0, 0]</code></pre>
<p>When <code>A</code> gossips with <code>B</code>, it sends an update along with the version number at which the update occured, in this case <code>1</code>. <code>B</code> updates the entry in the clock corresponding to <code>A</code>. It also increments its own entry in its clock to be one higher than <code>A</code>’s. Note that no individual update is marked with time 2, and none will be.</p>
<pre><code>A : [1, 0] 
B : [1, 2] </code></pre>
<p>Now B encounters a local update, so it increments it’s own clock.</p>
<pre><code>A: [1, 0] 
B: [1, 3]</code></pre>
<p>And sends the new update to A:</p>
<pre><code>A: [4, 3]
B: [1, 3]</code></pre>
</section></section>
<section class=container>
<section class=example><svg></svg></section>
<section id="conflict" class="level2">
<h2><a href="#conflict">Conflict</a></h2>
<p>How do peers decided when to apply updates? What happens if B encounters another local update?</p>
<pre><code>A: [4, 3] 
B: [1, 4]</code></pre>
<p>When B sends it’s update to A, A will merrily apply the update rules, arriving at:</p>
<pre><code>A: [5, 4]
B: [1, 4]</code></pre>
<p>But A is still left to resolve which of <code>[4, 3]</code> and <code>[1, 4]</code> came first. It turns out it cannot do so without appeal to external heauristics or physical time, a difficult task across a distributed network.</p>
<p>Lamport recommends reading <a href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=1091674&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D1091674"><em>Dissemination of System Time</em> by Ellingson et al.</a>, but the paper remains behind a tall paywall<sup><a href="#fn3" class="footnoteRef" id="fnref3">3</a></sup>, so I haven’t been able to read it.</p>
<p>During my research (furious googling for the most part), heuristics proved the more common approach. Some are maddeningly arbitrary. For example, <a href="https://wiki.apache.org/cassandra/FAQ#clocktie">Cassandra</a>, which uses scuttlebutt to propagate updates across its network, orders updates by their value. It gives primacy to <code>DELETE</code> operations, which is to say if <code>A</code> sent <code>DELETE key</code> to <code>B</code>, then no matter what the value of concurrent (as far as the vector clock is concerned) updates, <code>key</code> is deleted from the <code>B</code>’s store. If non-delete updates occur simultaneously, Cassandra saves the update which <strong>is lexically larger</strong>!</p>
<p>In the <a href="https://github.com/dominictarr/scuttlebutt/blob/master/model.js">scuttlebutt/model</a> of <a href="http://npmjs.org/scuttlebutt">npm.im/scuttlebutt</a>, <a href="https://github.com/dominictarr">@dominictarr</a> uses <em>last write wins</em>, and then <a href="https://github.com/dominictarr/scuttlebutt/blob/master/util.js#L29-L36">lexically compares</a> node names to resolve precedence ambiguities, essentially attributing credibility based on alphabetically sorting node names.</p>
<p>Even if we can definitively determine which update happend most recently, it is not at all clear that <em>last write wins</em> is the best way to determine whether an update should be applied. The constraints of the use case are going to determine the update rule, but it turns out this is a hard problem. so <em>Simple-Scuttle</em> <a href="https://github.com/AWinterman/simple-scuttle#constructor">leaves it to the client</a>.</p>
</section></section>
<section class=container>
<section class=example><svg></svg></section>
<section id="relation-to-npm.imscuttlebuttand-van-renesse-et-al." class="level2">
<h2><a href="#relation-to-npm.imscuttlebuttand-van-renesse-et-al.">Relation to npm.im/scuttlebuttand <em>van Renesse et al.</em></a></h2>
<p>My implementation, and consequently this module, was inspired by <a href="http://npmjs.org/scuttlebutt">Dominic Tarr’s scuttlebut module</a>. This module works, but I found the source hard to parse, which was problematic since it is designed to be subclassed. I also found it difficult to draw parallels between <a href="http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf">the paper</a> and this implementation. So I wrote my own.</p>
</section></section>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p><a href="http://nodejs.org/api/stream.html">Node Streams</a> abstractions built into the node core library for handling data over time. They present a unix-like api which allows one to write to sinks, read from sources, and pipe sources to sinks. They are available in the browser via <a href="http://browserify.org/">browserify</a>. <a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Logical time, as distinct from physical time, is essentially the count of events witnessed by the node. Physical time is somewhat similar— seconds count the number of times a physical clock’s second hand ticked, or the number of particles emitted from an atom.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>If anyone has contact information for the author, or is able to grant legitimate free access to the paper, please <a href="https://twitter.com/andywinterman">contact me</a>. <a href="#fnref3">↩</a></p></li>
</ol>
</section>
</article>
</body>
</html>
